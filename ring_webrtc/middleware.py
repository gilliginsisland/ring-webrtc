import asyncio
from typing import (
	Callable,
	Awaitable,
)
import signal
from datetime import (
	datetime,
	timedelta,
	timezone,
)
import logging

from aiohttp.web import (
	Request,
	StreamResponse,
	Application,
	middleware,
)

from .decorators import cleanup_ctx

_LOGGER = logging.getLogger(__name__)


def _now():
	return datetime.now(timezone.utc)


# Global shutdown function
def _shutdown(_: Application) -> None:
	"""
	Default shutdown function to send a SIGTERM to the current process.
	"""

	_LOGGER.info("Sending SIGTERM to terminate the application.")
	signal.raise_signal(signal.SIGTERM)


class IdleShutdown:
	"""
	Middleware class to track the last request time for an aiohttp app
	and shut it down after a period of idleness.
	"""

	def __init__(
		self,
		idle_timeout: int = 300,
		callback: Callable[[Application], None] = _shutdown,
	):
		"""
		Initialize the tracker with a default idle timeout (seconds) and shutdown callback.

		Args:
			idle_timeout: Time in seconds before shutting down due to idleness.
			callback: Shutdown callback function.
		"""

		self._idle_timeout: timedelta = timedelta(seconds=idle_timeout)
		self._callback: Callable[[Application], None] = callback
		self._last_request_time = _now()

	@middleware
	async def _middleware(
		self,
		request: Request,
		handler: Callable[[Request], Awaitable[StreamResponse]],
	) -> StreamResponse:
		"""
		Middleware function to track the last request time.

		Args:
			request: The incoming HTTP request.
			handler: An async callable that processes the request and returns a coroutine.

		Returns:
			StreamResponse: The HTTP response generated by the handler.
		"""

		_LOGGER.debug("Request received. Updating last request timestamp.")
		try:
			return await handler(request)
		finally:
			self._last_request_time = _now()

	def _is_idle(self):
		return _now() - self._last_request_time > self._idle_timeout

	async def _monitor_idle(self, app: Application) -> None:
		"""
		Loop forever to check for idle timeout and trigger the shutdown callback.
		"""

		sleep_interval = self._idle_timeout.total_seconds()

		_LOGGER.info(f'Starting idle monitoring for app: {app}.')
		while True:
			if self._is_idle():
				_LOGGER.info(f'Idle timeout detected. Triggering shutdown callback for app: {app}.')
				return self._callback(app)

			_LOGGER.debug(f'Not idle. Checking again in {sleep_interval} seconds: {app}')
			await asyncio.sleep(sleep_interval)

	def setup(self, app: Application) -> None:
		"""
		Entry point for the IdleShutdown class, used with app.cleanup_ctx.

		Args:
			app: The aiohttp application to monitor.

		Raises:
			RuntimeError: If another app is already being monitored.
		"""

		app.middlewares.append(self._middleware)
		app.cleanup_ctx.append(cleanup_ctx(self._monitor_idle))
