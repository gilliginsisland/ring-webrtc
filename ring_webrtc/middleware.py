import asyncio
from typing import (
	Callable,
	Awaitable,
	Coroutine,
)
from datetime import (
	timedelta,
)
import logging

from aiohttp.web import (
	Request,
	StreamResponse,
	Application,
	middleware,
)

from .helpers import (
	TaskWaitGroup,
	now,
	shutdown,
)
from .decorators import cleanup_ctx

CREATE_TASK = 'create_task'
_LOGGER = logging.getLogger(__name__)


class IdleShutdown:
	"""
	Middleware class to track the last request time for an aiohttp app
	and shut it down after a period of idleness.
	"""

	def __init__(
		self,
		idle_timeout: int,
		on_idle: Callable[[Application], None] = shutdown,
	):
		"""
		Initialize the tracker with a default idle timeout (seconds) and shutdown callback.

		Args:
			idle_timeout: Time in seconds before shutting down due to idleness.
			callback: Shutdown callback function.
		"""

		self._last_request_time = now()
		self._task_groups: set[TaskWaitGroup] = set()
		self._idle_timeout: timedelta = timedelta(seconds=idle_timeout)
		self._on_idle: Callable[[Application], None] = on_idle

	@middleware
	async def _middleware(
		self,
		request: Request,
		handler: Callable[[Request], Awaitable[StreamResponse]],
	) -> StreamResponse:
		"""
		Middleware function to track the last request time.

		Args:
			request: The incoming HTTP request.
			handler: An async callable that processes the request and returns a coroutine.

		Returns:
			StreamResponse: The HTTP response generated by the handler.
		"""
		task_group: TaskWaitGroup = TaskWaitGroup()
		self._task_groups.add(task_group)
		_LOGGER.debug(f'Request received. Active requests: {len(self._task_groups)}.')

		def create_task(coro: Coroutine):
			if not task_group in self._task_groups:
				raise RuntimeError('Task group is already closed.')
			task_group.add(asyncio.create_task(coro))

		request[CREATE_TASK] = create_task

		try:
			return await handler(request)
		finally:
			self._last_request_time = now()

			if not task_group:
				self._task_groups.remove(task_group)
				_LOGGER.debug(f'Request completed. Active requests: {len(self._task_groups)}.')
			else:
				_LOGGER.debug(f'Request handler completed. Task group count: {len(task_group)}.')
				task_group.add_done_callback(self._task_groups.remove)
				task_group.run()

	async def _monitor_idle(self, app: Application) -> None:
		"""
		Loop forever to check for idle timeout and trigger the shutdown callback.
		"""

		_LOGGER.info(f'Starting idle monitoring for app: {app}.')
		while True:
			if len(self._task_groups) > 0:
				self._last_request_time = now()

			idle_time = now() - self._last_request_time

			if idle_time > self._idle_timeout:
				_LOGGER.info(f'Idle timeout detected. Triggering shutdown callback for app: {app}.')
				try:
					self._on_idle(app)
				except Exception:
					_LOGGER.exception('Error during shutdown callback')
				return

			sleep_interval = (self._idle_timeout - idle_time).total_seconds()
			_LOGGER.debug(f'Not idle. Checking again in {sleep_interval} seconds: {app}')
			await asyncio.sleep(sleep_interval)

	def setup(self, app: Application) -> None:
		"""
		Entry point for the IdleShutdown class, used with app.cleanup_ctx.

		Args:
			app: The aiohttp application to monitor.

		Raises:
			RuntimeError: If another app is already being monitored.
		"""

		app.middlewares.append(self._middleware)
		app.cleanup_ctx.append(cleanup_ctx(self._monitor_idle))
